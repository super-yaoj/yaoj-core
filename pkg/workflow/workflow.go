package workflow

import (
	"encoding/json"
	"os"
	"time"

	"github.com/super-yaoj/yaoj-core/pkg/data"
	"github.com/super-yaoj/yaoj-core/pkg/utils"
	"github.com/super-yaoj/yaoj-core/pkg/yerrors"
)

// workflow 数据的来源（域）
type Groupname string

const (
	// 测试点的数据
	Gtests Groupname = "tests"
	// 整个题目的静态数据
	Gstatic Groupname = "static"
	// 参数者提交的数据
	Gsubm Groupname = "submission"
)

// Bound 可以理解为 Workflow 中结点的端口
type Bound struct {
	// name of the node
	Name string `json:"name"`
	// label of the input/output store
	Label string `json:"label"`
}

// Inbound 是读入数据的端口
type Inbound Bound

// Outboud 是输出数据的端口
type Outbound Bound

type Outbounds = map[string]Outbound

// Edge between nodes. Edges from field to node are stored in
// Workflow.Inbound.
type Edge struct {
	From Outbound `json:"from"`
	To   Inbound  `json:"to"`
}

// Node of workflow
type Node struct {
	// processor name
	ProcName string `json:"processor"`
	// whether caching its result in global cache
	Cache bool `json:"cache"`
}

// store the file path of workflow's inbound data
type InboundGroups map[Groupname]InboundGroup
type InboundGroup = map[string]data.FileStore

type InboundFields = map[string][]Inbound

// workflow describes how to perform a single testcase's judgement
//
// json marshalable
type Workflow struct {
	// All nodes of the workflow. Each node has its unique name, represented by
	// the key.
	Node map[string]Node `json:"node"`

	// All edges of the workflow. An edge is directed, connecting two different
	// nodes.
	Edge []Edge `json:"edge"`

	// Inbound stores edges from submission's fields to nodes.
	Inbound map[Groupname]InboundFields `json:"inbound"`
}

// Return all edges starting from Node[nodeid]
func (r *Workflow) EdgeFrom(name string) []Edge {
	res := []Edge{}
	for _, edge := range r.Edge {
		if edge.From.Name == name {
			res = append(res, edge)
		}
	}
	return res
}

// Return all edges ending at Node[nodeid]
func (r *Workflow) EdgeTo(name string) []Edge {
	res := []Edge{}
	for _, edge := range r.Edge {
		if edge.To.Name == name {
			res = append(res, edge)
		}
	}
	return res
}

// Transform workflow to its corresponding builder (for yaoj-cook)
func (r *Workflow) Builder() *Builder {
	var builder Builder
	for name, node := range r.Node {
		builder.SetNode(name, node.ProcName, false, node.Cache)
	}
	for _, edge := range r.Edge {
		builder.AddEdge(edge.From.Name, edge.From.Label, edge.To.Name, edge.To.Label)
	}
	for gname, group := range r.Inbound {
		for field, bounds := range group {
			for _, bound := range bounds {
				builder.AddInbound(gname, field, bound.Name, bound.Label)
			}
		}
	}
	return &builder
}

// Create an empty Workflow
func New() *Workflow {
	return &Workflow{
		Node:    map[string]Node{},
		Edge:    []Edge{},
		Inbound: map[Groupname]map[string][]Inbound{},
	}
}

// Load graph from serialized data (json)
func Load(serial []byte) (*Workflow, error) {
	var graph Workflow
	err := json.Unmarshal(serial, &graph)
	if err != nil {
		return nil, yerrors.Situated("Load", err)
	}
	return &graph, nil
}

// Load graph from (json) file.
func LoadFile(path string) (*Workflow, error) {
	serial, err := os.ReadFile(path)
	if err != nil {
		return nil, yerrors.Situated("LoadFile", err)
	}
	return Load(serial)
}

type ResultMeta struct {
	// e. g. "Accepted", "Wrong Answer"
	Title     string
	Score     float64
	Fullscore float64
	Time      time.Duration
	Memory    utils.ByteValue
}

// Result of a workflow, typically generated by Analyzer.
type Result struct {
	ResultMeta
	// a list of file content to display
	File []ResultFile
}

// json content
func (r *Result) Byte() []byte {
	data, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	return data
}

type ResultFile struct {
	Title   string
	Content string
}
